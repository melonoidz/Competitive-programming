{
	"Print to console1": {
		"prefix": "temp",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <atcoder/all>",
			"using namespace std;",
			"using ll=long long;",
			"#define int ll",
			"#define rng(i,a,b) for(int i=int(a);i<int(b);i++)",
			"#define rep(i,b) rng(i,0,b)",
			"#define ALL(a)  (a).begin(),(a).end()",
			"template<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}",
			"template<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}",
			"template<class t> using vc=vector<t>;",
			"template<class t> using vvc=vc<vc<t>>;",
			"using pi=pair<int,int>;",
			"using vi=vc<int>;",
			"using uint=unsigned;",
			"using ull=unsigned long long;",
			"int popcount(signed t){",
			"return __builtin_popcount(t);",
			"}",
			"int popcount(ll t){",
			"return __builtin_popcountll(t);",
			"}",
			"bool ispow2(int i){",
			"return i&&(i&-i)==i;",
			"}",
			"ll mask(int i){",
			"return (ll(1)<<i)-1;",
			"}",
			"int lcm(int a, int b)",
			"{",
			"return a / __gcd(a, b) * b;",
			"}",
			"signed main(){",
			"cin.tie(0);",
			"ios::sync_with_stdio(0);",
			"cout<<fixed<<setprecision(20);",
			"                                 ",
			"                                 ",
			"                                 ",
			"}"
		],
		"description": "template"
	},
	"Print to console2": {
		"prefix": "dijkstra",
		"body": [
			"vector<pi> edge[1100000];",
			"vector<int> dijkstra(int start){",
			"priority_queue<pi,vector<pi>,greater<pi>> pq;",
			"vector<int> dist(V,10e9);",
			"dist[start]=0;",
			"pq.push(pi(dist[start],start));",
			"while (!pq.empty()){",
			"auto p =pq.top(); pq.pop();",
			"int d= p.first;",
			"int from= p.second;",
			"if(dist[from]<d) continue;",
			"for(auto nxt: edge[from]){",
			"int to= nxt.first;",
			"int c= nxt.second;",
			"if(dist[from]+c <dist[to]){",
			"dist[to]=dist[from]+c;",
			"pq.push(pi(dist[to],to));",
			"}",
			"}",
			"}",
			"return dist;",
			"}"
		],
		"description": "dijkstra"
	},
	"Print to console3": {
		"prefix": "modint",
		"body": [
			"// auto mod int",
			"// https://youtu.be/L8grWxBlIZ4?t=9858",
			"// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize",
			"// https://youtu.be/8uowVvQ_-Mo?t=1329 : division",
			"const int mod = 1000000007;",
			"struct mint {",
			"int x; ",
			"mint(int x=0):x((x%mod+mod)%mod){}",
			"mint operator-() const { return mint(-x);}",
			"mint& operator+=(const mint a) {",
			"if ((x += a.x) >= mod) x -= mod;",
			" return *this;",
			" }",
			"mint& operator-=(const mint a) {",
			"if ((x += mod-a.x) >= mod) x -= mod;",
			"return *this;",
			"}",
			"mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}",
			"mint operator+(const mint a) const { return mint(*this) += a;}",
			" mint operator-(const mint a) const { return mint(*this) -= a;}",
			" mint operator*(const mint a) const { return mint(*this) *= a;}",
			"mint pow(int t) const {",
			" if (!t) return 1;",
			"mint a = pow(t>>1);",
			" a *= a;",
			"if (t&1) a *= *this;",
			"return a;",
			"}",
			"// for prime mod",
			"mint inv() const { return pow(mod-2);}",
			"mint& operator/=(const mint a) { return *this *= a.inv();}",
			"mint operator/(const mint a) const { return mint(*this) /= a;}",
			"};",
			"istream& operator>>(istream& is, const mint& a) { return is >> a.x;}",
			"ostream& operator<<(ostream& os, const mint& a) { return os << a.x;}"
		],
		"description": "modint"
	},
	"Print to console4": {
		"prefix": "combination",
		"body": [
			"// combination mod prime",
			"// https://www.youtube.com/watch?v=8uowVvQ_-Mo&feature=youtu.be&t=1619",
			"// [modint]",
			"struct combination {",
			"vector<mint> fact, ifact;",
			"combination(int n):fact(n+1),ifact(n+1) {",
			"assert(n < mod);",
			"fact[0] = 1;",
			"for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;",
			"ifact[n] = fact[n].inv();",
			"for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;",
			"}",
			"mint operator()(int n, int k) {",
			" if (k < 0 || k > n) return 0;",
			"return fact[n]*ifact[k]*ifact[n-k];",
			"}",
			"};"
		],
		"description": "combination"
	},
	"Print to console5": {
		"prefix": "randint",
		"body": [
			"ll rand_int(ll l, ll r) { //[l, r]",
			"#ifdef LOCAL",
			"static mt19937_64 gen;",
			"#else",
			"static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());",
			"#endif",
			"return uniform_int_distribution<ll>(l, r)(gen);",
			"}"
		],
		"description": "randint"
	},
	"Print to console6": {
		"prefix": "shuffle",
		"body": [
			"template<class t>",
			"void myshuffle(vc<t>&a){",
			"rep(i,si(a))swap(a[i],a[rand_int(0,i)]);",
			"}",
		],
		"description": "shuffle"
	},
	"Print to console7": {
		"prefix": "mkuni",
		"body": [
			"template <class t>",
			"void mkuni(vc<t> &v)",
			"{",
			"sort(all(v));",
			"v.erase(unique(all(v)), v.ed);",
			"}",
		],
		"description": "mkuni"
	},
	"Print to console8": {
		"prefix": "unionfind",
		"body": [
			"struct UnionFind {",
			"vector<int> par;",
			"UnionFind(int n) : par(n, -1) { }",
			"void init(int n) { par.assign(n, -1); }",
			"int root(int x) {",
			"if (par[x] < 0) return x;",
			"else return par[x] = root(par[x]);",
			"}",
			"bool issame(int x, int y) {",
			"return root(x) == root(y);",
			"}",
			"bool merge(int x, int y) {",
			"x = root(x); y = root(y);",
			"if (x == y) return false;",
			"if (par[x] > par[y]) swap(x, y); // merge technique",
			"par[x] += par[y];",
			"par[y] = x;",
			"return true;",
			"}",
			"int size(int x) {",
			"return -par[root(x)];",
			"}",
			"};",
		],
		"description": "unionfind"
	},"Print to console9": {
		"prefix": "dijkstra_grid",
		"body": [
			"//int h, w;",
			"//int dx[4] = {0, 0, 1, -1};",
			"//int dy[4] = {1, -1, 0, 0};",
			"//vc<vc<int>> g, dist;",
			"// g=field",
			"vc<vc<int>> dijkstra_grid(int sy, int sx) {",
			"dist.assign(h, vc<int>(w, 10e10));",
			"dist[sy][sx] = 0;",
			"priority_queue<pair<int, pi>, vc<pair<int, pi>>, greater<pair<int, pi>>> pq;",
			"pq.push(make_pair(0LL, make_pair(sy, sx)));",

			"while (!pq.empty()) {",
				"auto p = pq.top();",
				"pq.pop();",
				"int c = p.first;",
				"int vy = p.second.first;",
				"int vx = p.second.second;",
				"rep(i, 4) {",
				"int nx = vx + dx[i];",
					"int ny = vy + dy[i];",
					"if (ny < 0 || ny >= h || nx < 0 || nx >= w) continue;",
					"if (dist[ny][nx] <= g[ny][nx] + c) continue;",
					"dist[ny][nx] = g[ny][nx] + c;",
					"pq.push(make_pair(dist[ny][nx], make_pair(ny, nx)));",
				"}",
					"}",
					"return dist;",
			"}",
		],
		"description": "dijkstra_grid"
	},"Print to console10": {
		"prefix": "combandmodint",
		"body": [
			// modint (1000000007 で割ったあまりを扱う構造体)
"template <int MOD> struct Fp {",
"    long long val;",
"    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {",
"        if (val < 0) v += MOD;",
"    }",
"    constexpr int getmod() { return MOD; }",
"    constexpr Fp operator-() const noexcept { return val ? MOD - val : 0; }",
"    constexpr Fp operator+(const Fp& r) const noexcept {",
"        return Fp(*this) += r;",
"    }",
"    constexpr Fp operator-(const Fp& r) const noexcept {",
"        return Fp(*this) -= r;",
"    }",
"    constexpr Fp operator*(const Fp& r) const noexcept {",
"        return Fp(*this) *= r;",
"    }",
"    constexpr Fp operator/(const Fp& r) const noexcept {",
"        return Fp(*this) /= r;",
"    }",
"    constexpr Fp& operator+=(const Fp& r) noexcept {",
"        val += r.val;",
"        if (val >= MOD) val -= MOD;",
"        return *this;",
"    }",
"    constexpr Fp& operator-=(const Fp& r) noexcept {",
"        val -= r.val;",
"        if (val < 0) val += MOD;",
"        return *this;",
"    }",
    "constexpr Fp& operator*=(const Fp& r) noexcept {",
"        val = val * r.val % MOD;",
"        return *this;",
"    }",
"    constexpr Fp& operator/=(const Fp& r) noexcept {",
"        long long a = r.val, b = MOD, u = 1, v = 0;",
 "       while (b) {",
"            long long t = a / b;",
"            a -= t * b;",
"            swap(a, b);",
"            u -= t * v;",
"            swap(u, v);",
"        }",
"        val = val * u % MOD;",
"        if (val < 0) val += MOD;",
"        return *this;",
"    }",
"    constexpr bool operator==(const Fp& r) const noexcept {",
"        return this->val == r.val;",
"    }",
"    constexpr bool operator!=(const Fp& r) const noexcept {",
"        return this->val != r.val;",
"    }",
"    friend constexpr ostream& operator<<(ostream& os,",
"                                         const Fp<MOD>& x) noexcept {",
"        return os << x.val;",
"    }",
"    friend constexpr istream& operator>>(istream& is, Fp<MOD>& x) noexcept {",
"        return is >> x.val;",
"    }",
"    friend constexpr Fp<MOD> modpow(const Fp<MOD>& a, long long n) noexcept {",
"        if (n == 0) return 1;",
"        auto t = modpow(a, n / 2);",
"        t = t * t;",
"        if (n & 1) t = t * a;",
"        return t;",
"    }",
"};",
"// 二項係数ライブラリ",
"template <class T> struct BiCoef {",
"    vector<T> fact_, inv_, finv_;",
  "  constexpr BiCoef() {}",
"    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {",
"        init(n);",
"    }",
"    constexpr void init(int n) noexcept {",
"        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);",
"        int MOD = fact_[0].getmod();",
"        for (int i = 2; i < n; i++) {",
"            fact_[i] = fact_[i - 1] * i;",
"            inv_[i] = -inv_[MOD % i] * (MOD / i);",
"            finv_[i] = finv_[i - 1] * inv_[i];",
"        }",
"    }",
"    constexpr T com(int n, int k) const noexcept {",
"        if (n < k || n < 0 || k < 0) return 0;",
"        return fact_[n] * finv_[k] * finv_[n - k];",
"    }",
"    constexpr T fact(int n) const noexcept {",
"        if (n < 0) return 0;",
"        return fact_[n];",
"    }",
"    constexpr T inv(int n) const noexcept {",
"        if (n < 0) return 0;",
"        return inv_[n];",
"    }",
"    constexpr T finv(int n) const noexcept {",
"        if (n < 0) return 0;",
       " return finv_[n];",
    "}",
		"};",
		"const int MOD = 1000000007;",
		"using mint = Fp<MOD>;",
		"//BiCoef<mint> bc;",
		"//bc.init(110000);",
		],
		"description": "combandmodint"
	},"Print to console11": {
		"prefix": "div_enum",
		"body": [
			"vector<int> enum_divisors(int N) {",
				"vector<long long> res;",
				"for (long long i = 1; i * i <= N; ++i) {",
					"if (N % i == 0) {",
						"res.push_back(i);",
						"if (N/i != i) res.push_back(N/i);",
					"}",
				"}",
				"sort(res.begin(), res.end());",
				"return res;",
			"}",
		],
		"description": "div_enum"
	},"Print to console12": {
		"prefix": "prime_factorize",
		"body": [
			"vector<pair<long long, long long> > prime_factorize(long long N) {",
				"//12=({2,2},{3,1})",
				"vector<pair<long long, long long> > res;",
				"for (long long a = 2; a * a <= N; ++a) {",
					"if (N % a != 0) continue;",
					"long long ex = 0; // 指数",
					"while (N % a == 0) {",
						"++ex;",
						"N /= a;",
					"}",
					"res.push_back({a, ex});",
				"}",
				"if (N != 1) res.push_back({N, 1});",
				"return res;",
			"}",
		],
		"description": "prime_factorize"
	},"Print to console13": {
		"prefix": "modpow",
		"body": [
			"ll modpow(ll a, ll n, ll mod) {",
				"if (mod <= 0) return 0;",
				"ll res = 1;",
				"while (n > 0) {",
					"if (n & 1) res = res * a % mod;",
					"a = a * a % mod;",
					"n >>= 1;",
				"}",
				"return res;",
			"}",
		],
		"description": "modpow"
	},"Print to console14": {
		"prefix": "2Dimos",
		"body": [
		  "/**",
		  " * @brief Cumulative-Sum-2D(二次元累積和)",
		  " * @docs docs/cumulative-sum-2d.md",
		  " * add(x, y, z): 要素 (x,y)に値 z を加える.",
		  " * build(): 累積和を構築する.",
		  " * query(sx, sy, gx, gy): 左下 (sx,sy), 右上 (gx,gy) の矩形和を求める",
		  " * (半開区間で与えることに注意すること. 具体的には列 gx と行 gy は含まない)",
		  "*/",
		  "template< class T >",
		  "struct CumulativeSum2D {",
		  "  vector< vector< T > > data;",
		  "",
		  "  CumulativeSum2D(int W, int H) : data(W + 1, vector< int >(H + 1, 0)) {}",
		  "",
		  "  void add(int x, int y, T z) {",
		  "    ++x, ++y;",
		  "    if(x >= data.size() || y >= data[0].size()) return;",
		  "    data[x][y] += z;",
		  "  }",
		  "",
		  "  void build() {",
		  "    for(int i = 1; i < data.size(); i++) {",
		  "      for(int j = 1; j < data[i].size(); j++) {",
		  "        data[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];",
		  "      }",
		  "    }",
		  "  }",
		  "",
		  "  T query(int sx, int sy, int gx, int gy) const {",
		  "    return (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);",
		  "  }",
		  "};"
		],
		"description": "2次元累積和"
	  },"Print to console15": {
		"prefix": "digitsum",
		"body": [
			"int digit_sum(int x) {",
			"int ans = 0;",
			"while (x > 0) {",
			"ans += x % 10;",
			"x /= 10;",
			"}",
			"return ans;",
			"}"
		],
		"description": "桁和(int)"
	  },"Print to console16": {
		"prefix": "combmod(Extra)",
		"body": [
		  "// mod function",
		  "long long mod(long long a, long long mod) {",
		  "    return (a % mod + mod) % mod;",
		  "}",
		  "",
		  "long long modpow(long long a, long long n, long long mod) {",
		  "    long long res = 1;",
		  "    while (n > 0) {",
		  "        if (n & 1) res = res * a % mod;",
		  "        a = a * a % mod;",
		  "        n >>= 1;",
		  "    }",
		  "    return res;",
		  "}",
		  "",
		  "long long modinv(long long a, long long mod) {",
		  "    long long b = mod, u = 1, v = 0;",
		  "    while (b) {",
		  "        long long t = a/b;",
		  "        a -= t * b, swap(a, b);",
		  "        u -= t * v, swap(u, v);",
		  "    }",
		  "    u %= mod;",
		  "    if (u < 0) u += mod;",
		  "    return u;",
		  "}",
		  "",
		  "// binomial coefficient",
		  "struct BiCoef {",
		  "    // max size of n of nCr",
		  "    int n_;",
		  "    ",
		  "    // pm = p^k, p is prime",
		  "    // mod pm",
		  "    long long p_, pm_;",
		  "    ",
		  "    // i! = p^ord[i] * fact[i] (mod. m)",
		  "    vector<long long> ord_, fact_;",
		  "",
		  "    // constructor",
		  "    BiCoef(int n) : n_(n), ord_(n), fact_(n) {}",
		  "    BiCoef(long long p, long long pm, int n) :",
		  "        n_(n), p_(p), pm_(pm), ord_(n), fact_(n) {",
		  "        init(p, pm);",
		  "    }",
		  "    void init(int n) {",
		  "        ord_.resize(n);",
		  "        fact_.resize(n);",
		  "    }",
		  "    void init(long long p, long long pm) {",
		  "        p_ = p, pm_ = pm;",
		  "        ord_[0] = ord_[1] = 0;",
		  "        fact_[0] = fact_[1] = 1;",
		  "        for (int i = 2; i < n_; i++) {",
		  "            long long add = 0;",
		  "            long long ni = i;",
		  "            while (ni % p == 0) ++add, ni /= p;",
		  "            ord_[i] = ord_[i-1] + add;",
		  "            fact_[i] = fact_[ni-1] * ni % pm;",
		  "        }",
		  "    }",
		  "    void init(long long p, long long pm, int n) {",
		  "        init(n);",
		  "        init(p, pm);",
		  "    }",
		  "",
		  "    // nCr mod. pm",
		  "    long long com(long long n, long long r) {",
		  "        if (n < 0 || r < 0 || n < r) return 0;",
		  "        long long e = ord_[n] - ord_[r] - ord_[n-r];",
		  "        long long res = fact_[n] * modinv(fact_[r] * fact_[n-r] % pm_, pm_) % pm_;",
		  "        res = res * modpow(p_, e, pm_) % pm_;",
		  "        return res;",
		  "    }",
		  "};",
		  "//BiCoef bf(3, 3, N);",
		  "// bf(mod,mod,n)"
		],
		"description": "任意modCombination"
	  },"Print to console17": {
		"prefix": "Matrix",
		"body": [
			"typedef double Type;",
			"typedef vector<vector<Type>> Matrix;",
			"int GetRank(Matrix a) {",
			"    int h = a.size(), w = a[0].size();",
			"    int res = 0, now = 0;",
			"    for (int i = 0; i < h; i++) {",
			"        Type ma = 0.0;",
			"        int pivot;",
			"        for (int j = i; j < h; j++) {",
			"            if (a[j][now] > ma) {",
			"                ma = a[j][now];",
			"                pivot = j;",
			"            }",
			"        }",
			"        if (ma == 0.0) {",
			"            now++;",
			"            if (now == w) break;",
			"            i--;",
			"            continue;",
			"        }",
			"        if (pivot != i) {",
			"            for (int j = 0; j < w; j++) {",
			"                swap(a[i][j], a[pivot][j]);",
			"            }",
			"        }",
			"        Type tmp = 1.0 / a[i][now];",
			"        for (int j = 0; j < w; j++) a[i][j] *= tmp;",
			"        for (int j = 0; j < h; j++) {",
			"            if (i != j) {",
			"                Type tmp2 = a[j][now];",
			"                for (int k = 0; k < w; k++) {",
			"                    a[j][k] -= a[i][k] * tmp2;",
			"                }",
			"            }",
			"        }",
			"        res++;",
			"    }",
			"    return res;",
			"}",
			"bool Inv(Matrix a, Matrix& inv) {",
			"    assert(a.size() == a[0].size() && inv.size() == inv[0].size());",
			"    int n = a.size();",
			"    for (int i = 0; i < n; i++) {",
			"        for (int j = 0; j < n; j++) {",
			"            inv[i][j] = (i == j ? 1.0 : 0.0);",
			"        }",
			"    }",
			"    for (int i = 0; i < n; i++) {",
			"        Type ma = 0.0;",
			"        int pivot;",
			"        for (int j = i; j < n; j++) {",
			"            if (a[j][i] > ma) {",
			"                ma = a[j][i];",
			"                pivot = j;",
			"            }",
			"        }",
			"        if (ma == 0.0) return false;",
			"        if (pivot != i) {",
			"            for (int j = 0; j < n; j++) {",
			"                swap(a[i][j], a[pivot][j]);",
			"                swap(inv[i][j], inv[pivot][j]);",
			"            }",
			"        }",
			"        Type tmp = 1.0 / a[i][i];",
			"        for (int j = 0; j < n; j++) {",
			"            a[i][j] *= tmp;",
			"            inv[i][j] *= tmp;",
			"        }",
			"        for (int j = 0; j < n; j++) {",
			"            if (i != j) {",
			"                Type tmp2 = a[j][i];",
			"                for (int k = 0; k < n; k++) {",
			"                    a[j][k] -= a[i][k] * tmp2;",
			"                    inv[j][k] -= inv[i][k] * tmp2;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    return true;",
			"}",
			"Matrix Add(const Matrix& a, const Matrix& b, bool minus = false) {",
			"    assert(a.size() == b.size() && a[0].size() == b[0].size());",
			"    int h = a.size(), w = a[0].size();",
			"    Matrix c(h, vector<Type>(w));",
			"    for (int i = 0; i < h; i++) {",
			"        for (int j = 0; j < w; j++) {",
			"            c[i][j] = a[i][j] + (minus ? -1 : 1) * b[i][j];",
			"        }",
			"    }",
			"    return c;",
			"}",
			"Matrix Sub(const Matrix& a, const Matrix& b) { return Add(a, b, true); }",
			"Matrix Mul(const Matrix& a, const Matrix& b) {",
			"    assert(a[0].size() == b.size());",
			"    Matrix c(a.size(), vector<Type>(b[0].size()));",
			"    for (int i = 0; i < a.size(); i++) {",
			"        for (int k = 0; k < b.size(); k++) {",
			"            for (int j = 0; j < b[0].size(); j++) {",
			"                c[i][j] = (c[i][j] + a[i][k] * b[k][j]);",
			"            }",
			"        }",
			"    }",
			"    return c;",
			" }",
			"Matrix Pow(Matrix a, long long n) {",
			"        assert(a.size() == a[0].size());",
			"        Matrix b(a.size(), vector<Type> (a.size()));",
			"        for (int i = 0; i < a.size(); i ++) {",
			"                b[i][i] = 1;",
			"        }",
			"        while (n > 0) {",
			"                if (n & 1) b = Mul(b, a);",
			"                a = Mul(a, a);",
			"                n >>= 1;",
			"        }",
			"        return b;",
			"}",
			"void PrintMatrix(const Matrix &a) {",
			"        int h = a.size(), w = a[0].size();",
			"        for (int i = 0; i < h; i ++) {",
			"                for (int j = 0; j < w; j ++) {",
			"                        cout << a[i][j] << ' ';",
			"                }",
			"                cout << endl;",
			"        }",
			"}"

		],
		"description": "行列ライブラリ"
	  }
}