{
	"Print to console1": {
		"prefix": "temp",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <atcoder/all>",
			"using namespace std;",
			"using ll=long long;",
			"#define int ll",
			"#define rng(i,a,b) for(int i=int(a);i<int(b);i++)",
			"#define rep(i,b) rng(i,0,b)",
			"template<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}",
			"template<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}",
			"template<class t> using vc=vector<t>;",
			"template<class t> using vvc=vc<vc<t>>;",
			"using pi=pair<int,int>;",
			"using vi=vc<int>;",
			"using uint=unsigned;",
			"using ull=unsigned long long;",
			"int popcount(signed t){",
			"return __builtin_popcount(t);",
			"}",
			"int popcount(ll t){",
			"return __builtin_popcountll(t);",
			"}",
			"bool ispow2(int i){",
			"return i&&(i&-i)==i;",
			"}",
			"ll mask(int i){",
			"return (ll(1)<<i)-1;",
			"}",
			"int lcm(int a, int b)",
			"{",
			"return a / __gcd(a, b) * b;",
			"}",
			"signed main(){",
			"cin.tie(0);",
			"ios::sync_with_stdio(0);",
			"cout<<fixed<<setprecision(20);",
			"                                 ",
			"                                 ",
			"                                 ",
			"}"
		],
		"description": "template"
	},
	"Print to console2": {
		"prefix": "dijkstra",
		"body": [
			"vector<pi> edge[1100000];",
			"vector<int> dijkstra(int start){",
			"priority_queue<pi,vector<pi>,greater<pi>> pq;",
			"vector<int> dist(V,10e9);",
			"dist[start]=0;",
			"pq.push(P(dist[start],start));",
			"while (!pq.empty()){",
			"auto p =pq.top(); pq.pop();",
			"int d= p.first;",
			"int from= p.second;",
			"if(dist[from]<d) continue;",
			"for(auto nxt: edge[from]){",
			"int to= nxt.first;",
			"int c= nxt.second;",
			"if(dist[from]+c <dist[to]){",
			"dist[to]=dist[from]+c;",
			"pq.push(P(dist[to],to));",
			"}",
			"}",
			"}",
			"return dist;",
			"}"
		],
		"description": "dijkstra"
	},
	"Print to console3": {
		"prefix": "modint",
		"body": [
			"// auto mod int",
			"// https://youtu.be/L8grWxBlIZ4?t=9858",
			"// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize",
			"// https://youtu.be/8uowVvQ_-Mo?t=1329 : division",
			"const int mod = 1000000007;",
			"struct mint {",
			"int x; ",
			"mint(int x=0):x((x%mod+mod)%mod){}",
			"mint operator-() const { return mint(-x);}",
			"mint& operator+=(const mint a) {",
			"if ((x += a.x) >= mod) x -= mod;",
			" return *this;",
			" }",
			"mint& operator-=(const mint a) {",
			"if ((x += mod-a.x) >= mod) x -= mod;",
			"return *this;",
			"}",
			"mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}",
			"mint operator+(const mint a) const { return mint(*this) += a;}",
			" mint operator-(const mint a) const { return mint(*this) -= a;}",
			" mint operator*(const mint a) const { return mint(*this) *= a;}",
			"mint pow(int t) const {",
			" if (!t) return 1;",
			"mint a = pow(t>>1);",
			" a *= a;",
			"if (t&1) a *= *this;",
			"return a;",
			"}",
			"// for prime mod",
			"mint inv() const { return pow(mod-2);}",
			"mint& operator/=(const mint a) { return *this *= a.inv();}",
			"mint operator/(const mint a) const { return mint(*this) /= a;}",
			"};",
			"istream& operator>>(istream& is, const mint& a) { return is >> a.x;}",
			"ostream& operator<<(ostream& os, const mint& a) { return os << a.x;}"
		],
		"description": "modint"
	},
	"Print to console4": {
		"prefix": "combination",
		"body": [
			"// combination mod prime",
			"// https://www.youtube.com/watch?v=8uowVvQ_-Mo&feature=youtu.be&t=1619",
			"// [modint]",
			"struct combination {",
			"vector<mint> fact, ifact;",
			"combination(int n):fact(n+1),ifact(n+1) {",
			"assert(n < mod);",
			"fact[0] = 1;",
			"for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;",
			"ifact[n] = fact[n].inv();",
			"for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;",
			"}",
			"mint operator()(int n, int k) {",
			" if (k < 0 || k > n) return 0;",
			"return fact[n]*ifact[k]*ifact[n-k];",
			"}",
			"};"
		],
		"description": "combination"
	},
	"Print to console5": {
		"prefix": "randint",
		"body": [
			"ll rand_int(ll l, ll r) { //[l, r]",
			"#ifdef LOCAL",
			"static mt19937_64 gen;",
			"#else",
			"static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());",
			"#endif",
			"return uniform_int_distribution<ll>(l, r)(gen);",
			"}"
		],
		"description": "randint"
	},
	"Print to console6": {
		"prefix": "shuffle",
		"body": [
			"template<class t>",
			"void myshuffle(vc<t>&a){",
			"rep(i,si(a))swap(a[i],a[rand_int(0,i)]);",
			"}",
		],
		"description": "shuffle"
	},
	"Print to console7": {
		"prefix": "mkuni",
		"body": [
			"template <class t>",
			"void mkuni(vc<t> &v)",
			"{",
			"sort(all(v));",
			"v.erase(unique(all(v)), v.ed);",
			"}",
		],
		"description": "mkuni"
	},
	"Print to console8": {
		"prefix": "unionfind",
		"body": [
			"struct UnionFind {",
			"vector<int> par;",
			"UnionFind(int n) : par(n, -1) { }",
			"void init(int n) { par.assign(n, -1); }",
			"int root(int x) {",
			"if (par[x] < 0) return x;",
			"else return par[x] = root(par[x]);",
			"}",
			"bool issame(int x, int y) {",
			"return root(x) == root(y);",
			"}",
			"bool merge(int x, int y) {",
			"x = root(x); y = root(y);",
			"if (x == y) return false;",
			"if (par[x] > par[y]) swap(x, y); // merge technique",
			"par[x] += par[y];",
			"par[y] = x;",
			"return true;",
			"}",
			"int size(int x) {",
			"return -par[root(x)];",
			"}",
			"};",
		],
		"description": "unionfind"
	},"Print to console9": {
		"prefix": "dijkstra_grid",
		"body": [
			"//int h, w;",
			"//int dx[4] = {0, 0, 1, -1};",
			"//int dy[4] = {1, -1, 0, 0};",
			"//vc<vc<int>> g, dist;",
			"// g=field",
			"vc<vc<int>> dijkstra_grid(int sy, int sx) {",
			"dist.assign(h, vc<int>(w, 10e10));",
			"dist[sy][sx] = 0;",
			"priority_queue<pair<int, pi>, vc<pair<int, pi>>, greater<pair<int, pi>>> pq;",
			"pq.push(make_pair(0LL, make_pair(sy, sx)));",

			"while (!pq.empty()) {",
				"auto p = pq.top();",
				"pq.pop();",
				"int c = p.first;",
				"int vy = p.second.first;",
				"int vx = p.second.second;",
				"rep(i, 4) {",
				"int nx = vx + dx[i];",
					"int ny = vy + dy[i];",
					"if (ny < 0 || ny >= h || nx < 0 || nx >= w) continue;",
					"if (dist[ny][nx] <= g[ny][nx] + c) continue;",
					"dist[ny][nx] = g[ny][nx] + c;",
					"pq.push(make_pair(dist[ny][nx], make_pair(ny, nx)));",
				"}",
					"}",
					"return dist;",
			"}",
		],
		"description": "dijkstra_grid"
	},
}